"""Building-level data model and processing manager for multi-floor indoor navigation.

This module owns high-level building semantics:
- Floor metadata and occupancy per floor
- Room indexing and room metadata
- Inter-floor connectors (stairs/elevators)
- Real-world coordinate conversion helpers

All world-space values are in meters.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any

import cv2
import numpy as np
from shapely.geometry import Point, Polygon

from backend.detection import (
    adaptive_hough_params,
    detect_doors,
    detect_walls,
    extract_walls_from_mask,
    filter_door_candidates,
    filter_wall_segments,
    merge_collinear_wall_segments,
)
from backend.grid import walls_to_occupancy_grid
from backend.preprocessing import preprocess_blueprint


@dataclass(slots=True)
class RoomMeta:
    """Room metadata extracted from a floor plan.

    Attributes:
        room_id: Stable room identifier (e.g., F1-R003).
        floor_number: Floor index for this room.
        name: Human-readable label (auto-generated by default).
        centroid_m: Room centroid in world meters (x, y, z).
        polygon_m: Room boundary polygon in world meters (x, z) on floor plane.
        area_m2: Estimated floor area in square meters.
    """

    room_id: str
    floor_number: int
    name: str
    centroid_m: tuple[float, float, float]
    polygon_m: list[tuple[float, float]]
    area_m2: float


@dataclass(slots=True)
class FloorMeta:
    """Single floor metadata and raster navigation state.

    Attributes:
        floor_number: Integer floor index.
        elevation_m: Absolute floor elevation in world space.
        image_shape_px: Source blueprint image dimensions (height, width).
        cell_size_m: Occupancy cell size in meters.
        grid: 2D occupancy grid (0 free, 1 occupied).
        model_url: Optional floor-specific model URL.
        rooms: Room metadata list for this floor.
    """

    floor_number: int
    elevation_m: float
    image_shape_px: tuple[int, int]
    cell_size_m: float
    grid: np.ndarray
    model_url: str | None = None
    rooms: list[RoomMeta] = field(default_factory=list)


@dataclass(slots=True)
class ConnectorMeta:
    """Inter-floor connector metadata (stairs/elevator shaft).

    Attributes:
        connector_id: Unique connector identifier.
        connector_type: "stairs" or "elevator".
        floors: Sorted list of connected floor numbers.
        position_m: Connector center point in world meters (x, y, z).
        radius_m: Connector traversal radius in meters.
    """

    connector_id: str
    connector_type: str
    floors: list[int]
    position_m: tuple[float, float, float]
    radius_m: float = 0.5


@dataclass(slots=True)
class BuildingMeta:
    """Whole-building metadata and navigation model state."""

    building_id: str
    origin_m: tuple[float, float, float]
    floor_height_m: float
    floors: dict[int, FloorMeta] = field(default_factory=dict)
    connectors: list[ConnectorMeta] = field(default_factory=list)


class BuildingManager:
    """In-memory building manager for multi-floor processing and lookup.

    Typical usage:
        manager = BuildingManager(building_id="HQ-A")
        manager.process_floor_blueprint(floor_number=1, image_bgr=image)
        manager.add_connector("C1", "stairs", [1, 2], (12.0, 0.0, 8.0))
        floors_payload = manager.get_floors_payload()
    """

    def __init__(
        self,
        building_id: str,
        origin_m: tuple[float, float, float] = (0.0, 0.0, 0.0),
        floor_height_m: float = 3.2,
        default_cell_size_m: float = 0.2,
        model_scale_m_per_px: float = 0.05,
    ) -> None:
        """Initialize manager with world coordinate settings.

        Args:
            building_id: Unique building key.
            origin_m: Global origin in meters (x, y, z).
            floor_height_m: Vertical spacing between floors.
            default_cell_size_m: Occupancy grid cell size.
            model_scale_m_per_px: Blueprint pixel-to-meter conversion scale.
        """
        if floor_height_m <= 0:
            raise ValueError("floor_height_m must be > 0")
        if default_cell_size_m <= 0:
            raise ValueError("default_cell_size_m must be > 0")
        if model_scale_m_per_px <= 0:
            raise ValueError("model_scale_m_per_px must be > 0")

        self.meta = BuildingMeta(
            building_id=building_id,
            origin_m=origin_m,
            floor_height_m=floor_height_m,
        )
        self.default_cell_size_m = default_cell_size_m
        self.model_scale_m_per_px = model_scale_m_per_px

    def process_floor_blueprint(
        self,
        floor_number: int,
        image_bgr: np.ndarray,
        cell_size_m: float | None = None,
        hough_threshold: int = 60,
    ) -> FloorMeta:
        """Process one floor blueprint into occupancy and room metadata.

        Steps:
            1) Preprocess blueprint
            2) Detect walls
            3) Rasterize occupancy grid
            4) Detect rooms from free-space segmentation

        Args:
            floor_number: Floor index.
            image_bgr: Raw blueprint image.
            cell_size_m: Optional cell size override.
            hough_threshold: Wall line detection threshold.

        Returns:
            Populated FloorMeta object.
        """
        if floor_number < 0:
            raise ValueError("floor_number must be >= 0")

        resolved_cell_m = self.default_cell_size_m if cell_size_m is None else cell_size_m
        if resolved_cell_m <= 0:
            raise ValueError("cell_size_m must be > 0")

        pre = preprocess_blueprint(image_bgr)
        hough_thr, hough_min_len, hough_gap = adaptive_hough_params(pre["gray"].shape)
        hough_walls = detect_walls(
            pre["edges"],
            threshold=max(hough_thr, max(70, hough_threshold)),
            min_line_length=hough_min_len,
            max_line_gap=hough_gap,
        )
        mask_walls = extract_walls_from_mask(pre["denoised"])
        walls = [*hough_walls, *mask_walls]
        walls = filter_wall_segments(
            walls,
            pre["gray"].shape,
            primary_bbox=pre.get("primary_bbox"),
            bbox_margin_px=max(18, int(min(pre["gray"].shape) * 0.015)),
            support_mask=pre.get("denoised"),
            min_support_ratio=0.1 if bool(pre.get("ml_used")) else 0.2,
            min_median_half_thickness_px=0.85 if bool(pre.get("ml_used")) else 1.2,
        )
        walls = merge_collinear_wall_segments(walls)
        doors = detect_doors(
            pre["binary"],
            walls,
            door_mask=pre.get("door_mask"),
            prefer_ml_only=bool(pre.get("ml_used")),
        )
        doors = filter_door_candidates(
            doors,
            pre["gray"].shape,
            primary_bbox=pre.get("primary_bbox"),
            bbox_margin_px=max(18, int(min(pre["gray"].shape) * 0.015)),
        )

        cell_size_px = max(1, int(round(resolved_cell_m / self.model_scale_m_per_px)))
        grid, _ = walls_to_occupancy_grid(
            image_shape=pre["gray"].shape,
            walls=walls,
            cell_size_px=cell_size_px,
            inflation_radius_px=1,
            door_candidates=doors,
            door_clearance_px=3,
        )

        elevation_m = self.meta.origin_m[1] + floor_number * self.meta.floor_height_m
        rooms = self._extract_rooms_from_grid(
            floor_number=floor_number,
            grid=grid,
            cell_size_m=resolved_cell_m,
            elevation_m=elevation_m,
        )

        floor_meta = FloorMeta(
            floor_number=floor_number,
            elevation_m=elevation_m,
            image_shape_px=pre["gray"].shape,
            cell_size_m=resolved_cell_m,
            grid=grid,
            rooms=rooms,
        )

        self.meta.floors[floor_number] = floor_meta
        return floor_meta

    def add_connector(
        self,
        connector_id: str,
        connector_type: str,
        floors: list[int],
        position_m: tuple[float, float, float],
        radius_m: float = 0.5,
    ) -> ConnectorMeta:
        """Register a stairs/elevator connector for vertical navigation.

        Args:
            connector_id: Unique connector key.
            connector_type: "stairs" or "elevator".
            floors: Floors connected by this connector.
            position_m: World-space connector center.
            radius_m: Connector usable radius.

        Returns:
            Connector metadata instance.
        """
        if connector_type not in {"stairs", "elevator"}:
            raise ValueError("connector_type must be 'stairs' or 'elevator'")
        if len(floors) < 2:
            raise ValueError("connector must connect at least two floors")
        if radius_m <= 0:
            raise ValueError("radius_m must be > 0")

        connector = ConnectorMeta(
            connector_id=connector_id,
            connector_type=connector_type,
            floors=sorted(set(floors)),
            position_m=position_m,
            radius_m=radius_m,
        )

        self.meta.connectors = [c for c in self.meta.connectors if c.connector_id != connector_id]
        self.meta.connectors.append(connector)
        return connector

    def get_floor(self, floor_number: int) -> FloorMeta:
        """Fetch floor metadata or raise if unknown."""
        if floor_number not in self.meta.floors:
            raise KeyError(f"Floor {floor_number} is not available")
        return self.meta.floors[floor_number]

    def list_rooms(self, floor_number: int | None = None) -> list[RoomMeta]:
        """List rooms on one floor or across all floors."""
        if floor_number is not None:
            return list(self.get_floor(floor_number).rooms)

        rooms: list[RoomMeta] = []
        for floor in sorted(self.meta.floors.keys()):
            rooms.extend(self.meta.floors[floor].rooms)
        return rooms

    def find_room_by_id(self, room_id: str) -> RoomMeta | None:
        """Find room metadata by unique room ID."""
        for room in self.list_rooms():
            if room.room_id == room_id:
                return room
        return None

    def find_room_by_world_point(self, x_m: float, y_m: float, z_m: float) -> RoomMeta | None:
        """Map world coordinate to containing room polygon.

        The Y coordinate determines floor, and X/Z are tested against room polygons.
        """
        floor_number = int(round((y_m - self.meta.origin_m[1]) / self.meta.floor_height_m))
        if floor_number not in self.meta.floors:
            return None

        point = (x_m, z_m)
        for room in self.meta.floors[floor_number].rooms:
            polygon = Polygon(room.polygon_m)
            if polygon.contains(Point(point[0], point[1])):
                return room
        return None

    def world_to_grid(self, floor_number: int, x_m: float, z_m: float) -> tuple[int, int]:
        """Convert world meters to grid row/col on a specific floor."""
        floor = self.get_floor(floor_number)
        row = int(round(z_m / floor.cell_size_m))
        col = int(round(x_m / floor.cell_size_m))

        row = max(0, min(floor.grid.shape[0] - 1, row))
        col = max(0, min(floor.grid.shape[1] - 1, col))
        return row, col

    def grid_to_world(self, floor_number: int, row: int, col: int) -> tuple[float, float, float]:
        """Convert floor-local grid row/col to world meters (x, y, z)."""
        floor = self.get_floor(floor_number)
        x_m = col * floor.cell_size_m
        y_m = floor.elevation_m
        z_m = row * floor.cell_size_m
        return x_m, y_m, z_m

    def get_floors_payload(self) -> dict[str, Any]:
        """Serialize building and floor metadata for GET /floors payload."""
        floors = []
        for floor_num in sorted(self.meta.floors.keys()):
            floor = self.meta.floors[floor_num]
            floors.append(
                {
                    "floor_number": floor.floor_number,
                    "elevation_m": floor.elevation_m,
                    "cell_size_m": floor.cell_size_m,
                    "rows": int(floor.grid.shape[0]),
                    "cols": int(floor.grid.shape[1]),
                    "model_url": floor.model_url,
                    "room_count": len(floor.rooms),
                }
            )

        return {
            "building_id": self.meta.building_id,
            "origin_m": self.meta.origin_m,
            "floor_height_m": self.meta.floor_height_m,
            "connectors": [
                {
                    "connector_id": c.connector_id,
                    "connector_type": c.connector_type,
                    "floors": c.floors,
                    "position_m": c.position_m,
                    "radius_m": c.radius_m,
                }
                for c in self.meta.connectors
            ],
            "floors": floors,
        }

    def get_rooms_payload(self) -> dict[str, Any]:
        """Serialize room metadata for GET /rooms payload."""
        return {
            "building_id": self.meta.building_id,
            "rooms": [
                {
                    "room_id": room.room_id,
                    "floor_number": room.floor_number,
                    "name": room.name,
                    "centroid_m": room.centroid_m,
                    "polygon_m": room.polygon_m,
                    "area_m2": room.area_m2,
                }
                for room in self.list_rooms()
            ],
        }

    def _extract_rooms_from_grid(
        self,
        floor_number: int,
        grid: np.ndarray,
        cell_size_m: float,
        elevation_m: float,
    ) -> list[RoomMeta]:
        """Extract room regions from free-space connected components.

        Implementation notes:
            - Occupied cells (1) are treated as walls/obstacles
            - Free cells (0) are segmented into connected components
            - Small components are discarded as noise/corridor artifacts
        """
        free_mask = (grid == 0).astype(np.uint8)
        num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(free_mask, connectivity=8)

        rooms: list[RoomMeta] = []
        room_index = 1
        min_cells = max(8, int(6.0 / max(0.05, cell_size_m)))

        for label in range(1, num_labels):
            area_cells = int(stats[label, cv2.CC_STAT_AREA])
            if area_cells < min_cells:
                continue

            coords = np.argwhere(labels == label)
            if coords.size == 0:
                continue

            # Build convex hull as a coarse room boundary in grid space.
            hull_points = cv2.convexHull(coords[:, ::-1].astype(np.float32))
            hull_points = hull_points.reshape(-1, 2)

            polygon_m = [(float(x * cell_size_m), float(y * cell_size_m)) for x, y in hull_points]
            centroid_row = float(np.mean(coords[:, 0]))
            centroid_col = float(np.mean(coords[:, 1]))
            centroid_m = (
                centroid_col * cell_size_m,
                elevation_m,
                centroid_row * cell_size_m,
            )

            room_id = f"F{floor_number}-R{room_index:03d}"
            rooms.append(
                RoomMeta(
                    room_id=room_id,
                    floor_number=floor_number,
                    name=f"Room {room_index}",
                    centroid_m=centroid_m,
                    polygon_m=polygon_m,
                    area_m2=float(area_cells * (cell_size_m**2)),
                )
            )
            room_index += 1

        return rooms
